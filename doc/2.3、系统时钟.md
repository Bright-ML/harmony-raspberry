# 源码分析

## 一.系统时钟初始化

### 1.main函数的各种调用,验证参数

kernel\liteos_a\platform\main.c->main()

​	kernel\liteos_a\kernel\common\los_config.c->OsMain()

​		kernel\liteos_a\arch\arm\arm\src\los_hw_tick.c->OsTickInit()

```c
systemClock		//vendor里设置的是50000000
tickPerSecond	//鸿蒙默认设置的是100
LITE_OS_SEC_TEXT_INIT UINT32 OsTickInit(UINT32 systemClock, UINT32 tickPerSecond)
{    //只是验证了下传入的这两个参数,并未使用
    HalClockInit();
    return LOS_OK;
}
```

### 2.先获取当前时钟频率,注册中断

kernel\liteos_a\platform\hw\arm\timer\arm_generic\arm_generic_timer.c

```c
OS_TICK_INT_NUM//中断号,在vendor\***\***\board\include\asm\hal_platform_ints.h下定义,查手册确定
MIN_INTERRUPT_PRIORITY//优先级
OsTickEntry//中断函数
LITE_OS_SEC_TEXT_INIT VOID HalClockInit(VOID)
{   ...
    g_sysClock = HalClockFreqRead(); //先获取当前时钟频率
    
	//调用LOS_HwiCreate函数新建中断，系统中断由它注册
    ret = LOS_HwiCreate(OS_TICK_INT_NUM, MIN_INTERRUPT_PRIORITY, 0, OsTickEntry, 0);//参数1:中断号、参数4:执行函数
    //这个函数就不深入了，大体就是将中断号好和对应的执行函数放到一个数组
    //比如这里就是，当发生OS_TICK_INT_NUM这个中断时，执行OsTickEntry()函数
    ...
}
```

## 二.时钟中断的执行函数OsTickEntry()

kernel\liteos_a\platform\hw\arm\timer\arm_generic\arm_generic_timer.c

```c
不过此时这是注册了这个函数，时钟并未启动，得执行了（三.启动时钟）之后才会调用这个函数
LITE_OS_SEC_TEXT VOID OsTickEntry(VOID)
{
    TimerCtlWrite(0);
    OsTickHandler();
    TimerCvalWrite(TimerCvalRead() + OS_CYCLE_PER_TICK);
    TimerCtlWrite(1);
    //使用最后一个cval生成下一个tick的时间是绝对和准确的。不要使用tval来驱动一般时间，在这种情况下tick会变慢。
}
```

## 三.启动时钟

main() => OsStart(VOID) => OsTickStart() => HalClockStart(VOID)

kernel\liteos_a\platform\hw\arm\timer\arm_generic\arm_generic_timer.c => HalClockStart(VOID)

```c
//树莓派2b没有GIC所以这个函数要爆改
LITE_OS_SEC_TEXT_INIT VOID HalClockStart(VOID)
{
    HalIrqUnmask(OS_TICK_INT_NUM);  //wendor里定义的 OS_TICK_INT_NUM = 29
    TimerCtlWrite(0);
    TimerTvalWrite(OS_CYCLE_PER_TICK);
    TimerCtlWrite(1);
}
```

### 1. HalIrqUnmask; //接收中断（通过设置寄存器，允许CPU响应该中断）

```
HalIrqUnmask(OS_TICK_INT_NUM);
HalIrqUnmask(29);
GIC_REG_32(GICD_ISENABLER(29 >> 5)) = 1U << (29 % 32);

(GICD_ISENABLER(29 >> 5))拆开
GIC_REG_32(GICD_OFFSET + 0x100 + (29 >> 5) * 4) = 1U << (29 % 32);/* 中断使能 Registers */

GIC_REG_32拆开，(29 % 32)=1D
GIC_BASE_ADDR + (GICD_OFFSET + 0x100 + (29 >> 5) * 4) = 1U << (29 % 32)

#define GIC_BASE_ADDR             IO_DEVICE_ADDR(0x3F00A100)
#define GICD_OFFSET               0x1000     /* interrupt distributor offset */
```

### 2.TimerCtlWrite(0); //关闭Timer

参考：`ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition.pdf`

《B3.17 Organization of the CP15 registers in a VMSA implementation》

```
WRITE_TIMER_REG32(TIMER_REG_CTL, 0);
ARM_SYSREG_WRITE(TIMER_REG_CTL, 0)
ARM_SYSREG_WRITE(TIMER_REG(_CTL), 0)
ARM_SYSREG_WRITE(CP15_REG(c14, 0, c2, 1)), 0)
"mcr " (CP15_REG(c14, 0, c2, 1) :: "r" (val)
反汇编
r8 0
mcr	p15, #0, r8, c14, c2, #1	CNTP_CTL,PL1物理定时器控制寄存器
```

### 3.TimerTvalWrite(OS_CYCLE_PER_TICK); //设置Tval

```
反汇编
r0 192000
mcr	p15, #0, r0, c14, c2, #0	CNTP_TVAL,PL1物理时间值寄存器
```

### 4.TimerCtlWrite(1);	//再开启Timer

```
反汇编
r5 1
mcr	p15, #0, r5, c14, c2, #1	CNTP_CTL,PL1物理定时器控制寄存器
```

# 代码移植

Z:\bright\harmony-100ask\kernel\liteos_a\platform\hw\arm\interrupt\gic\gic_v2.c

```c
VOID HalIrqUnmask(UINT32 vector)
{
    if ((vector > OS_USER_HWI_MAX) || (vector < OS_USER_HWI_MIN)) {
        return;
    }
    //GIC_REG_32(GICD_ISENABLER(vector >> 5)) = 1U << (vector % 32);  //替换
	*(volatile UINT32 *)((UINTPTR)IO_DEVICE_ADDR(0x3F00B218)) = 1; //使能ARM Timer IRQ	

}
```

Z:\bright\harmony-100ask\kernel\liteos_a\platform\hw\arm\timer\arm_generic\arm_generic_timer.c

```c
STATIC_INLINE VOID TimerCtlWrite(UINT32 cntpCtl)
{
    //WRITE_TIMER_REG32(TIMER_REG_CTL, cntpCtl);//替换
    if(cntpCtl == 0){
		*(volatile UINT32 *)((UINTPTR)IO_DEVICE_ADDR(0x3F00B408)) = 0x003E0000;
    	}
	else
	{
		*(volatile UINT32 *)((UINTPTR)IO_DEVICE_ADDR(0x3F00B408)) = 0x003E00A2;
	}
}

STATIC_INLINE VOID TimerTvalWrite(UINT32 tval)
{
    //WRITE_TIMER_REG32(TIMER_REG_TVAL, tval);//替换
	*(volatile UINT32 *)((UINTPTR)IO_DEVICE_ADDR(0x3F00B400)) = tval;  //设置倒计时时间，鸿蒙是10ms	
}
```

