## 1、鸿蒙的系统时钟

操作系统运行多任务，需要tick中断来切换Task，tick中断由Timer产生，主要文件kernel\liteos_a\platform\hw\arm\timer\arm_generic\arm_generic_timer.c，这篇文章就来分析这个文件。

而Timer的驱动文件在kernel\liteos_a\platform\bsp.mk进行了设置，这段代码也是之前添加单板时添加的。

```c
########################## LOSCFG_PLATFORM_RASPBERRYPI2B Options##############################
else ifeq ($(LOSCFG_PLATFORM_RASPBERRYPI2B), y)
    HWI_TYPE     := arm/interrupt/gic
    TIMER_TYPE   := arm/timer/arm_generic
    HRTIMER_TYPE := BCM2836/hrtimer
    #UART_TYPE    := amba_pl011
endif
```

TIMER_TYPE  := arm/timer/arm_generic 设置了Timer驱动的文件路径。arm_generic_timer.c从文件名字也可以看出这是ARM通用的Timer驱动。ARM的标准无疑可以简化Timer的移植过程，可惜的是树莓派2的Timer并不能完全的适用，可以查看《BCM2835-ARM-Peripherals.pdf：196页》所以得进行修改才行。

### 1.1、系统tick的初始化流程

kernel\liteos_a\platform\main.c->main()

​	kernel\liteos_a\kernel\common\los_config.c->OsMain()

​		kernel\liteos_a\arch\arm\arm\src\los_hw_tick.c->OsTickInit()

接下来就分析源码，看懂源码修改并不复杂。

vendor\broadcom\BCM2836\board\include\platform_config.h丨#define OS_SYS_CLOCK   50000000

kernel\liteos_a\kernel\common\los_config.h丨#define LOSCFG_BASE_CORE_TICK_PER_SECOND   100

```c
systemClock		//50000000
tickPerSecond	//100
LITE_OS_SEC_TEXT_INIT UINT32 OsTickInit(UINT32 systemClock, UINT32 tickPerSecond)
{    //只是验证了下传入的这两个参数,并未使用
    HalClockInit();
    return LOS_OK;
}
```

### 1.2、先获取当前时钟频率,注册中断

kernel\liteos_a\platform\hw\arm\timer\arm_generic\arm_generic_timer.c

```c
OS_TICK_INT_NUM//中断号,在vendor\***\***\board\include\asm\hal_platform_ints.h下定义,查手册确定
MIN_INTERRUPT_PRIORITY//优先级
OsTickEntry//中断函数
LITE_OS_SEC_TEXT_INIT VOID HalClockInit(VOID)
{   ...
    g_sysClock = HalClockFreqRead(); //先获取当前时钟频率
    
	//调用LOS_HwiCreate函数新建中断，系统中断由它注册
    ret = LOS_HwiCreate(OS_TICK_INT_NUM, MIN_INTERRUPT_PRIORITY, 0, OsTickEntry, 0);//参数1:中断号、参数4:执行函数
    //这个函数就不深入了，大体就是将中断号好和对应的执行函数放到一个数组
    //比如这里就是，当发生OS_TICK_INT_NUM这个中断时，执行OsTickEntry()函数
    ...
}
```

## 2、时钟中断的执行函数OsTickEntry()

kernel\liteos_a\platform\hw\arm\timer\arm_generic\arm_generic_timer.c

```c
不过此时这是注册了这个函数，时钟并未启动，得执行了（HalClockStart）之后才会调用这个函数
LITE_OS_SEC_TEXT VOID OsTickEntry(VOID)
{
    TimerCtlWrite(0);
    *(volatile UINT32 *)((UINTPTR)IO_DEVICE_ADDR(0x3F00B40C)) = 0; //添加一句，中断挂起位清除，不然一直执行中断
    OsTickHandler();
    TimerCvalWrite(TimerCvalRead() + OS_CYCLE_PER_TICK);
    TimerCtlWrite(1);
    //使用最后一个cval生成下一个tick的时间是绝对和准确的。不要使用tval来驱动一般时间，在这种情况下tick会变慢。
}
```

## 3、启动时钟

main() => OsStart(VOID) => OsTickStart() => HalClockStart(VOID)

kernel\liteos_a\platform\hw\arm\timer\arm_generic\arm_generic_timer.c => HalClockStart(VOID)

```c
LITE_OS_SEC_TEXT_INIT VOID HalClockStart(VOID)
{
    HalIrqUnmask(OS_TICK_INT_NUM); //中断使能
    TimerCtlWrite(0);
    TimerTvalWrite(OS_CYCLE_PER_TICK);
    TimerCtlWrite(1);
}
```

### 3.1、 HalIrqUnmask; //中断使能

```
HalIrqUnmask(OS_TICK_INT_NUM);
HalIrqUnmask(1);
GIC_REG_32(GICD_ISENABLER(1 >> 5)) = 1U << (1 % 32);

(GICD_ISENABLER(1 >> 5))拆开
GIC_REG_32(GICD_OFFSET + 0x100 + (1 >> 5) * 4) = 1U << (1 % 32);/* 中断使能 Registers */

GIC_REG_32拆开，(1 % 32)=1D
GIC_BASE_ADDR + (GICD_OFFSET + 0x100 + (1 >> 5) * 4) = 1U << (1 % 32)

#define GIC_BASE_ADDR             IO_DEVICE_ADDR(0x3F00A100)
#define GICD_OFFSET               0x1000     /* interrupt distributor offset */
```

拆解HalIrqUnmask发现，使能中断并没有使用cp15协处理器指令，而是通过设置MemoryMepped寄存器。所以移植树莓派需要确定中断号和寄存器地址。

OS_TICK_INT_NUM //中断号：在vendor\broadcom\BCM2836\board\include\asm\hal_platform_ints.h下定义，可以查手册确定。

使能ARM Timer IRQ：GIC是通用的中断控制器，也是ARM的标准，但是树莓派2、3都没有，所以这里要修改。

Z:\bright\harmony-100ask\kernel\liteos_a\platform\hw\arm\interrupt\gic\gic_v2.c

```c
VOID HalIrqUnmask(UINT32 vector)
{
    if ((vector > OS_USER_HWI_MAX) || (vector < OS_USER_HWI_MIN)) {
        return;
    }
    //GIC_REG_32(GICD_ISENABLER(vector >> 5)) = 1U << (vector % 32);  //替换
	*(volatile UINT32 *)((UINTPTR)IO_DEVICE_ADDR(0x3F00B218)) = vector;
    //可以直接赋值中断号，树莓派2中1是ARM Timer中断，参考《BCM2835-ARM-Peripherals.pdf：113》
}
```

### 3.2、TimerCtlWrite(0); //关闭Timer

```
WRITE_TIMER_REG32(TIMER_REG_CTL, 0);
ARM_SYSREG_WRITE(TIMER_REG_CTL, 0)
ARM_SYSREG_WRITE(TIMER_REG(_CTL), 0)
ARM_SYSREG_WRITE(CP15_REG(c14, 0, c2, 1)), 0)
"mcr " (CP15_REG(c14, 0, c2, 1) :: "r" (val)
汇编指令：r8 0
mcr	p15, #0, r8, c14, c2, #1	CNTP_CTL,PL1物理定时器控制寄存器
```

从这个函数的汇编指令可以看出，它使用的是cp15协处理器指令。移植到树莓派需要修改成下面的代码。

Z:\bright\harmony-100ask\kernel\liteos_a\platform\hw\arm\timer\arm_generic\arm_generic_timer.c

```c
STATIC_INLINE VOID TimerCtlWrite(UINT32 cntpCtl)
{
    //WRITE_TIMER_REG32(TIMER_REG_CTL, cntpCtl);//替换
    if(cntpCtl == 0)
    {
		*(volatile UINT32 *)((UINTPTR)IO_DEVICE_ADDR(0x3F00B408)) = 0x003E0000;
    }
	else
	{
		*(volatile UINT32 *)((UINTPTR)IO_DEVICE_ADDR(0x3F00B408)) = 0x003E00A2;
	}
}
```

### 3.3、TimerTvalWrite(OS_CYCLE_PER_TICK); //设置Tval

```c
汇编指令：r0 192000
mcr	p15, #0, r0, c14, c2, #0	CNTP_TVAL,PL1物理时间值寄存器
```

原理同上，移植到树莓派。

```c
STATIC_INLINE VOID TimerTvalWrite(UINT32 tval)
{
    //WRITE_TIMER_REG32(TIMER_REG_TVAL, tval);//替换
	*(volatile UINT32 *)((UINTPTR)IO_DEVICE_ADDR(0x3F00B400)) = tval;  //设置倒计时时间，鸿蒙是10ms //测试，19200000/20大约1s	
}
```

### 3.4、TimerCtlWrite(1);	//再开启Timer

参考：3.2、TimerCtlWrite(0); //关闭Timer

```
汇编指令：r5 1
mcr	p15, #0, r5, c14, c2, #1	CNTP_CTL,PL1物理定时器控制寄存器
```

TODO：

```c
STATIC_INLINE UINT64 TimerCvalRead(VOID)  
{
    return READ_TIMER_REG64(TIMER_REG_CVAL);//测试证明这个是TimerCvalRead是可以读到值的，使用的内嵌汇编，mrrc * *，单步的时候可以查查汇编指令
	//return *(volatile UINT32 *)((UINTPTR)IO_DEVICE_ADDR(0x3F00B404));		
}
```

现在的问题是System Timer Compare 0值如何设置，才可以触发中断，这个点还不清楚。《BCM2835-ARM-Peripherals.pdf：174》

Tval和Cval在树莓派中的区别在哪也没找到，虽然现在timer可以使用，但是精度怕是不行，运行短时间内是没有问题的。